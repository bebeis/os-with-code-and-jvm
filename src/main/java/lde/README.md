# 9. 제한적 직접 실행 원리(Limited Direct Execution, LDE)
#OS/OSTEP/이론/가상화

맨 첫장에서 살펴본 것 처럼, 운영체제는 여러 작업들이 동시에 실행되는 것 처럼 보이도록 하기 위해 물리적인 CPU를 공유하고, **시간을 나누어 쓰는 시분할 기법**을 사용하여 **가상화**를 구현한다.

이러한 가상화 기법을 구현하기 위해서는 몇 가지 문제를 해결해야 한다.
1. **성능 저하** : 시스템에 과중한 **오버헤드**를 주지 않으면서 가상화를 구현해야 한다.
2. **제어 문제** : **CPU에 대한 통제를 유지**하면서 프로세스를 효율적으로 실행시켜야 한다.

운영체제 입장에서는 CPU에 제어권을 넘겨 영원히 제어권을 상실하면 한 프로세스가 영원히 실행되고, 또는 해당 프로세스가 컴퓨터를 장악하거나 접근해서는 안되는 정보에 접근할 수 있다.

우리는 운영체제가 제어를 유지하면서 효과적으로 CPU를 가상화하도록 하는 방법을 찾아야 한다.
- 이를 위해선 하드웨어와 운영체제의 지원이 필수적이다.

## 9.1 기본 원리 : 제한적 직접 실행
운영체제 개발자들은 프로그램을 빠르게 실행하기 위하여 **제한적 직접 실행(Limited Direct Execution)** 기법을 개발하였다.

### 직접 실행
그렇다면 **’직접 실행’** 이라는게 뭔지 먼저 알아보자.
직접 실행은 프로그램을 CPU 상에서 그냥 직접 실행시키는 것이다. 우리가 아는 아래와 같은 과정이다.
- 프로그램 실행 시 프로세스 목록에 해당 프로세스 항목 만들기
- 메모리 할당, 프로그램 코드 탑재
- entry point로 분기, 실행
  ![](img/image.png)<!-- {"width":502} -->
  위의 **직접 실행** 접근법은 CPU 가상화에 있어서 몇 가지 문제를 일으킨다.
1. 프로그램을 직접 실행시킨다면 프로그램이 운영체제가 원치 않는 일을 하지 않도록 어떻게 보장할 것인가?
2. CPU 가상화에 필요한 **시분할** 기법을 어떻게 구현할 것인가?
   ![](img/image%204.png)<!-- {"width":512} -->
   프로그램 실행에 제한을 두지 않으면 운영체제는 어떠한 제어도 할 수 없다. 그래서 “제한적” 직접 실행 이라는 이름이 붙은 것이다.

## 9.2 문제점 1: 제한된 연산
**직접 실행**의 장점은 **빠르게 실행**된다는 것이다. CPU에서 프로그램이 직접 실행되기 때문이다.
하지만 CPU에서 직접 실행시키면 **새로운 문제**가 발생한다.
- 프로세스가 특수한 종류의 연산을 수행하려고 하면 어떻게 할 것인가?
    - ex) 디스크 I/O, 시스템 자원에 대한 추가 할당 요청

이에 대한 해결책으로, *프로세스가 원하는 대로 할 수 있게 방치하는 방안*이 있다.
- 문제점: 예를 들어 파일에 대한 접근 권한을 검사하는 파일 시스템을 구현한다고 해보자. 디스크 입/출력을 제한하지 않으면 프로세스가 전체 디스크를 읽고 쓸 수 있기 때문에 접근 권한 검사 기능이 의미가 없어진다.

따라서, 프로세스는 결국에는 제한된 연산(ex. 디스크 I/O)을 수행해야 한다. 그런데 시스템에 대한 권한이 없으면 제한된 연산을 수행할 수 없다. 이를 위해서 OS와 하드웨어는 어떤 역할을 할까?
- 하드웨어는 **사용자 모드**와 **커널 모드**라는 두 가지 실행 모드를 제공하여 운영체제를 돕는다.
    - **사용자 모드**에서는 응용 프로그램이 하드웨어 자원에 대한 접근 권한이 일부 제한된다.
        - 실행되는 코드는 할 수 있는 일이 제한된다.
        - ex) 프로세스가 사용자모드에서 실행중이면 입출력 요청을 할 수 없도록 설정한다. 입출력을 요청하면 예외를 발생시켜 OS가 프로세스를 제거하도록  한다.
    - 운영체제는 컴퓨터의 모든 자원에 대한 접근 권한을 **커널 모드**에서 가진다.
        - 커널 모드로 진입하기 위한 `trap` 명령어, 사용자 모드로 돌아가기 위한 `return-from-trap` 명령어가 제공된다.
        - 이 모드에서는 모든 특수한 명령어를 포함하는 원하는 모든 작업을 수행할 수 있다.

사용자 프로세스가 디스크 읽기 같은 특권 명령어를 실행하기 위해선 어떻게 해야할까?
- 만약 커널 모드를 직접 사용한다면 여전히 위험할 것이다.
- 제한 작업 실행을 허용하기 위해 현대 하드웨어는 **시스템 콜**을 제공한다.
    - 커널은 시스템 콜을 통하여 자신의 주요 기능을 사용자 프로그램에 제공한다.

**시스템 콜을 실행**하기 위해서는 프로그램은 `trap` **특수 명령어를 실행**해야 한다.
- 이 명령어는 **커널 안으로 분기**하는 동시에 **특권 수준을 커널 모드로 상향 조정**한다.
- 커널 모드로 진입하면 **운영체제는** 모든 명령어를 실행할 수 있고, 프로세스가 요청한 작업을 처리할 수 있다.
- 작업이 완료되면 운영체제는 `return-from-trap`  특수 명령어를 호출한다.
    - 특권 수준을 **사용자 모드로 다시 하향 조정**한다.

trap 명령어를 수행할 때 **하드웨어의 역할**도 중요하다.
- 호출한 프로세스의 필요한 **레지스터들을 저장**해야 한다.
    - `return-from-trap` 명령어 실행 시 사용자 프로세스를 제대로 **리턴**할 수 있도록 하기 위함이다.
- x86의 경우 프로그램 카운터, 플래그 같은 레지서트를 각 프로세스의 **커널 스택**에 저장한다.
    - `return-from-trap` 실행 시 pop되어 사용자 모드 프로그램 실행을 다시 시작한다.

![](img/image%205.png)<!-- {"width":682} -->
> [!NOTE] **시스템 콜은 프로시저 콜과 비슷하다.**
> 실제로 C 프로그램에서 시스템 콜을 호출하는 건 함수 호출과 형태가 똑같다. 그렇다면 운영체제는 어떻게 둘을 구분할 수 있을까?
>
> 예를 들어, `open()`을 호출하면, **라이브러리는** 커널과 약속된 호출 규약을 사용하여 `open()` 에 전달할 인자와 시스템 콜 번호를 지정된 장소(스택, or 레지스터)에 저장한다. 그런 다음 trap 명령어를 실행한다. 그 다음 반환 값을 정리하고 호출 프로그램에게 제어를 넘긴다.
>
> C 라이브러리에서 시스템 콜을 호출하는 부분의 코드는 어셈블리어로 작성된다. 우리는 운영체제로 진입하기 위해 어셈블리 코드를 직접 작성할 필요가 없다.

Q) trap이 **운영체제의 코드의 어디를 실행**할 지 어떻게 알 수 있을까?
- 호출한 프로세서는 분기할 주소를 명시할 수 없다. 커널 내부의 원하는 지점을 명시하는 것 자체가 위험하다.

A) 커널은 부팅 시에 **트랩 테이블**을 만들고 시스템을 통제한다.
- 컴퓨터가 부트될 때 커널 모드에서 동작하므로, 하드웨어를 원하는 대로 제어가능하다.
- 운영체제가 하는 초기 작업 중하나는 하드웨어에게 예외 사건이 일어났을 때 어떤 코드를 실행해야 하는지 알려준다.
    - 운영체제는 특정 명령어를 사용하여 하드웨어에게 **트랩 핸들러**의 위치를 알려준다.
    - 따라서 **시스템 콜과 같은 예외적인 사건이 발생했을 때 하드웨어는 무엇을 해야 할 지(어느 코드로 분기하여 실행할지) 알 수 있다.**

> 하드웨어에게 트랩 테이블의 위치를 알려주는 것도 특권 명령어이다. 이걸 잘못 손대면 큰일난다…
![](img/image%202.png)<!-- {"width":530} -->

- 프로세스는 **커널 스택**을 **각자** 가지고 있다. 커널 모드로 진입하거나 진출할 때 **하드웨어**에 의해 프로그램 카운터, 범용 레지스터 등의 레지스터가 저장되고 복원되는 용도로 사용된다.

LDE 프로토콜(제한적 직접 실행 프로토콜)은 두 단계로 진행된다.
1. 전반부(부팅)에서 커널은 트랩 테이블을 초기화하고 CPU는 나중에 사용하기 위하여 테이블 위치를 기억한다.
2. 후반부(프로세스 실행)에서 `return-from-trap`을 이용하여 사용자 프로세스를 시작할 때 몇 가지 작업을 수행한다.
    - 새로운 프로세스를 위한 노드를 할당하여 프로세스 리스트에 삽입, 메모리 할당 작업을 포함
    - `return-from-trap` 명령어는 CPU를 사용자 모드로 전환하고 프로세스 실행을 시작한다.
    - 프로세스가 시스템 콜을 호출하면 운영체제로 다시 트랩된다.
    - 운영체제는 시스템 콜을 처리하고 `return-from-trap` 명령어를 사용하여 제어를 프로세스에게 넘긴다.
    - 프로세스 이후 자신의 할 일을 다하면 `main()`에서 리턴한다.
        - 이 때 스텁 코드로 리턴하고, 스텁 코드가 프로그램을 종료시킨다.
        - 종료시킬 때 `exit()` 시스템 콜을 호출하고 다시 운영체제로 트랩된다.

## 9.3 문제점 2: 프로세스 간 전환
앞에서는 제한된 연산을 수행하는 과정에 대해 살펴봤다.
남은 문제점은 프로세스 간 전환을 할 수 있어야 한다는 점이다. 계속 실행할 지, 멈추고 다른 프로세스를 실행할지 말이다.

그런데 CPU에서 프로그램이 실행 중이라는 것은, 운영체제는 실행 중이지 않다는 것을 의미한다. 운영체제가 실행하고 있지 않은데 프로세스 간 전환을 어떻게 할 수 있을까?

> 여기서 나는, 운영체제는 제어권이 없다. 즉, CPU를 실행 중인 프로세스가 스스로 놔주는 방법 밖에는 없다고 생각했다.

### 협조 방식 : 시스템 콜 기다리기
**협조(cooperative)** 방식은 과거의 몇몇 시스템에서 채택한 방식이다.
이 방식은 **운영체제가 프로세스들이 합리적으로 행동할 것이라고 신뢰한다.**
- 프로세스가 스스로 “운영체제가 다른 작업을 실행할 결정을 할 수 있도록 주기적으로 CPU를 포기” 할 것이라고 가정한다.

만약에 정말 이상적으로 그렇다고 치자. 이 프로세스는 어떻게 CPU를 포기할 수 있을까?
- 우리는 프로세스가 **시스템 콜을 호출하여 CPU 제어권을 운영체제에 넘겨줄** 수 있다는 것을 알고 있다.
    - 예를 들어, 파일 I/O 등의 작업에서 시스템 콜을 한다.
- 이런 유형의 OS에서는 **yield** 시스템 콜을 제공하고, 이 시스템 콜은 운영체제에게 제어를 넘겨 운영체제가 다른 프로세스를 실행할 수 있게 한다.

> Q) 자바에도 **thread.yield()**가 존재하는데, 비슷한 개념인가?

시스템 콜 외에도 CPU 제어권이 운영체제로 넘어가는 경우가 한 가지 더 있다.
- 응용 프로그램이 비정상적인 행위를 하게되면 운영체제는 오작동 프로세스를 처리해야할 의무가 있으므로 제어가 운영체제에게 넘어간다. (CPU가 감지하여 트랩을 발생시킨다.)
    - ex) 0으로 나누기, 접근할 수 없는 메모리에 접근
- 운영체제는 CPU를 획득하여 해당 행위를 하는 프로세스를 종료시킨다.
    - 현대 시스템에서는 부정 행위 프로세스를 바로 종료시킨다.

### 비협조 방식 : 운영체제가 전권을 행사
이상적인 상황에서 벗어나보자. 만약에 시스템 콜을 호출할 수 없을 때는 어떤 일이 발생할까?
- 이 경우 제어가 운영체제에게 넘어오지 않으므로 하드웨어의 추가적인 도움 없이는 운영체제가 할 수 있는 일은 거의 없다.
- 협조적 방식에서는 컴퓨터를 재부팅해야 한다.

프로세스가 비협조적인 상황에서도 CPU 제어를 획득하는 방법은 무엇일까?
-> **타이머 인터럽트(timer interrupt)** 를 이용한다.
- 수 밀리 초마다 인터럽트를 발생시키도록 프로그래밍 하는 것이다. (CPU 외부 장치(ex. APIC Timer)가 CPU에 신호 전달)
- 인터럽트가 발생하면 프로세스는 중단되고 미리 구성된 운영체제의 **인터럽트 핸들러(interrupt handler)**가 실행된다.
- 이 시점에 운영체제는 CPU 제어권을 다시 얻게 되고 자신이 원하는 일을 할 수 있다.

> **타이머 인터럽트 하드웨어 기능**은 운영체제가 컴퓨터 제어를 유지하는 핵심 기능이다.

이를 위해, 운영체제는 하드웨어에게 타이머 인터럽트가 발생했을 때 실행해야 할 코드를 알려주어야 한다.
- 부팅 시점에 이 준비를 한다.

> 참고로 타이머는 특정 명령어를 수행하여 끌 수도 있다.

인터럽트 발생 시 하드웨어에게도 약간의 역할이 있다. 실행 중이던 프로그램의 상태를 저장하여 나중에 `return-from-trap` 명령어가 프로그램을 다시 시작할 수 있도록 해야 한다.
- 시스템 콜이 호출되었을 때 하드웨어가 하는 동작과 유사하다.
- 커널 스택에 레지스터가 저장되고, `return-from-trap` 명령어를 통해 복원된다.

### 문맥의 저장과 복원
어찌됬던 운영체제가 제어권을 획득하면 실행 중인 프로세스를 계속 실행 할지, 아니면 다른 프로세스로 전환할 지 결정해야 한다.
- 운영체제의 **스케줄러**에 의해 결정된다.

만약 다른 프로세스로 전환하기로 결정되면, **문맥 교환(context switch, 컨텍스트 스위치)**라고 알려진 코드를 실행한다.
- 현재 실행 중인 프로세스의 레지스터 값을 커널 스택 같은 곳에 저장하고 곧 실행될 프로세스의 커널 스택으로부터 레지스터 값을 복원하는 것이 전부다.
  ![](img/image%206.png)
> **주의!** PCB는 커널 스택 전체를 저장하는 것이 아니라, **"레지스터 값들이 저장된 커널 스택의 위치"**를 저장한다.
> - 컨텍스트 스위치 과정 중에는 커널 스택의 push/pop도 일어나고
> - PCB의 프로세스 상태(Running/Ready), 커널 스택 포인터 값 등도 변경된다. (PCB의 스택 포인터는 커널 스택의 top을 가리키기 때문)
> - 참고) 커널 스택의 bottom 주소는 “고정되어 있다.” 프로세스/스레드가 생성될 때 커널이 한 번 정해주고 절대 변하지 않는다”.

더 자세히 살펴보면,
- 프로세스 전환을 위해 운영체제는 저수준 어셈블리 코드를 사용하여 현재 실행 중인 프로세스의 범용 레지스터, PC, 현재 커널 스택 포인터를 저장한다.
- 곧 실행될 프로세스의 범용 레지스터, PC를 복원하고 커널 스택을 이 프로세스의 커널 스택으로 전환한다.
- 이로써 운영체제는 실행될 프로세스 문맥으로 리턴할 수 있다.

![](img/image%203.png)<!-- {"width":646} -->
- 프로세스 A가 실행 중이고 타이머 인터럽트에 의해 중단된다.
- 하드웨어 A의 레지스터를 커널 스택에 저장하고 커널 모드로 이동한다.
- 타이머 인터럽트 핸들러에서 운영체제는 프로세스 B로 전환하기로 결정한다.
    - 이 시점에 `switch()` 루틴을 호출한다.
- 이 루틴이 A 레지스터 값을 A의 프로세스 구조체에 저장하고, B의 프로세스 구조체에서 B 레지스터를 복원한다.
- 이후 A 커널 스택 대신 B 커널 스택을 사용하도록 스택 포인터(=CPU의 SP 레지스터)를 바꾸어 **문맥 교환**을 수행한다.
- 마지막으로 운영체제는 `return-from-trap`을 수행하여 B의 레지스터를 복원하고 실행을 시작한다.

주의할 점은, 이 과정 중에서 **두 번의 레지스터 저장/복원**이 일어난다는 것이다.
1. 첫 번째, 타이머 인터럽트 발생 시 실행 중인 프로세스의 사용자 레지스터가 **하드웨어에 의해** 암묵적으로 저장되고 저장 장소로 해당 프로세스의 커널 스택이 사용된다.
2. 두 번째, 운영체제가 A에서 B로 전환하기로 결정했을 때 일어난다. 이 때 커널 레지스터는 **운영체제**에 의해 해당 프로세스의 프로세스 구조체에 저장된다.
    - 인터럽트로 인해 이미 커널 스택에 저장된 레지스터 말고, 커널 코드가 추가로 사용하는 레지스터들도 프로세스 A의 PCB(task_struct)에 저장하는 과정을 말한다.
    - 인터럽트가 발생하면 일단 사용자 모드의 레지스터는 무조건 커널 스택에 저장된다. 그런데 만약 스케줄링 결과로 컨텍스트 스위치까지 하기로 결정되었다면, 최후의 보루인 커널 레지스터도 저장한다. 인터럽트 되었어도 OS는 커널 영역에서 실행중인 것이고, 커널도 CPU 레지스터를 사용하기 때문이다.
    - 즉, PCB는 아래 두 정보를 포함한다.
        - 프로세스가 마지막으로 “커널 모드”였을 때의 레지스터 값
        - 프로세스의 커널 스택 포인터(top)

> **왜 커널 스택이 별도로 필요할까?**
> 프로세스가 시스템 콜, 인터럽트를 해서 커널 모드로 진입하면, 커널도 결국 **함수 호출, 지역 변수 저장, 리턴 주소 관리**가 필요하다. CPU는 모드 전환(User → Kernel) 순간, 그 프로세스의 **커널 스택으로 자동 전환**한다. 그 때문에 **모든 프로세스마다 고유한 커널 스택**이 있다.
>
> 이 스택이 없으면:
> * 커널이 함수 호출을 할 수 없음
> * 인터럽트 처리 중 스택 덮어쓰기 위험
    > ⠀즉, **프로세스 분리와 커널 안정성을 위해 필요하다.** (프로세스 코드랑 커널 코드 실행에 따른 저장 값은 분리하는게 좋으니까)

## 9.4 병행성이 걱정
“만약 시스템 콜을 처리하는 도중 타이머 인터럽트가 발생하면 어떻게 될까?”
“하나의 인터럽트 처리 중 다른 인터럽트가 발생하면 어떻게 될까?”
- 이에 대해 신중히 고려해야 한다. 뒤에서 다룬다.

간단한 해법은, 인터럽트를 처리하는 동안 **인터럽트를 불능화**시키는 것이다.
- 인터럽트 처리 중 다른 어떤 인터럽트도 CPU에 전달되지 않는다.
- 오랜 불능화는 인터럽트를 놓치게 되고 기술적으로 좋지 않다.

실제로 현대 운영체제는 정교한 **락(lock)** 기법을 활용해 커널 안에서 다수의 활동이 진행될 수 있게 허용한다.

## 9.5 요약
- CPU 가상화를 구현하기 위한 핵심적인 저수준 기법을 묶어 **제한적 직접 실행**이라 부른다.
- 운영체제가 CPU를 사용하지 못하더라도 프로세스의 작업을 제한할 수 있도록 하드웨어를 셋업해야 한다.
    - 아기 보호 장치를 설치하는 것과 비슷하다. 위험 요소를 막아두어, 자유롭게 돌아나니게 한다.
    - 트랩 핸들러 함수, 인터럽트 타이머를 사용하고 제한된 모드에서만 프로세스가 실행되도록 한다.
- 이로써 운영체제는 특별한 연산을 수행할 때, 즉 프로세스가 CPU를 독점하거나, 다른 프로세스로 전환해야 할 때만 개입한다.

## 정리
### 빠르지만 위험한 방법, 직접 실행
운영체제는 CPU 가상화를 통해 여러 프로세스가 동시에 실행되는 것처럼 보이게 만들어야 한다. 이 목표를 달성하기 위한 가장 단순하고 빠른 방법은 무엇일까? 바로 **직접 실행(Direct Execution)**, 즉 프로그램을 CPU 위에서 곧바로 실행시키는 것이다.
하지만 이 방식은 마치 운전면허가 없는 사람에게 자동차 키를 주는 것과 같다. 프로그램이 CPU를 직접 제어하게 되면, 악의적인 작업을 수행하거나 무한 루프에 빠져 CPU를 독점해버려도 운영체제가 이를 막을 방법이 없다. 😱 속도는 얻지만 **제어권**을 잃게 되는 치명적인 문제가 발생한다.

### 첫 번째 안전장치: 사용자 모드와 커널 모드
이 제어권 문제를 해결하기 위해, 하드웨어는 CPU에 두 가지 작동 모드(**Mode**)를 두었다.
* **사용자 모드 (User Mode)**: 일반 응용 프로그램이 실행되는, 권한이 제한된 모드이다. 이 모드에서는 디스크 접근이나 메모리 관리 같은 중요한 작업(특권 명령)을 직접 수행할 수 없다.
* **커널 모드 (Kernel Mode)**: 운영체제(OS) 코드가 실행되는, 모든 권한을 가진 전능한 모드이다. 시스템의 모든 자원에 접근하고 제어할 수 있다.

⠀이제 프로그램은 안전한 **사용자 모드**에서 직접 실행된다. 그러다 디스크 I/O 같은 특권 명령이 필요해지면, 그냥 실행하는 것이 아니라 운영체제에게 정중하게 도움을 요청해야 한다.

### 유일한 통로, 시스템 콜과 트랩
사용자 모드의 프로세스가 커널 모드의 운영체제에게 서비스를 요청하는 유일하고 합법적인 절차를 **시스템 콜(System Call)**이라고 한다.
프로세스가 시스템 콜을 호출하면, CPU는 **트랩(Trap)**이라는 특수 명령을 실행한다. 이 트랩은 다음과 같은 일을 순식간에 처리한다.
1. CPU의 작동 모드를 사용자 모드에서 **커널 모드로 전환**한다.
2. 제어권을 운영체제의 정해진 코드(트랩 핸들러)로 넘긴다.

⠀운영체제는 커널 모드에서 요청받은 작업을 안전하게 처리한 뒤, return-from-trap 명령을 통해 다시 사용자 모드로 돌아가 원래 프로세스의 실행을 재개시킨다. 이로써 프로그램의 실행을 제한하면서도 필요한 기능은 제공할 수 있게 된다. 이것이 바로 **"제한적" 직접 실행**의 첫 번째 핵심 원리이다.

### 최후의 보루, 타이머 인터럽트
그런데 만약 프로그램이 시스템 콜을 전혀 호출하지 않고 무한 루프에 빠진다면 어떻게 될까? 운영체제는 영원히 제어권을 돌려받지 못하고 시스템은 멈추게 된다.
이런 비협조적인 상황을 막기 위한 최후의 안전장치가 바로 **타이머 인터럽트(Timer Interrupt)**이다. ⏰
운영체제는 부팅 시 하드웨어 타이머에 "몇 밀리초(ms) 후에 나를 깨워줘"라고 설정한다. 시간이 되면 타이머는 CPU에 전기 신호(인터럽트)를 보내고, CPU는 무슨 일을 하던 간에 현재 작업을 강제로 멈춘다. 그리고 제어권은 무조건 운영체제의 **인터럽트 핸들러**로 넘어오게 된다.
이 타이머 인터럽트 덕분에 운영체제는 주기적으로 반드시 제어권을 되찾아와서, 계속 한 프로세스를 실행할지 다른 프로세스로 전환할지를 결정할 수 있다.

### 제어권을 찾은 후의 선택: 문맥 교환
타이머 인터럽트나 시스템 콜을 통해 운영체제가 제어권을 획득하면, 스케줄러는 이제 어떤 프로세스를 실행할지 결정한다. 만약 다른 프로세스(B)를 실행하기로 결정했다면 **문맥 교환(Context Switch)**이 일어난다.
문맥 교환은 다음과 같은 과정이다.
1. 현재 실행 중이던 프로세스(A)의 레지스터 값 등 모든 상태(**문맥**)를 메모리(A의 PCB)에 저장한다.
2. 다음에 실행할 프로세스(B)의 저장된 문맥을 B의 PCB에서 가져와 CPU 레지스터에 복원한다.
3. 프로세스 B의 실행을 시작한다.

⠀이 과정을 통해 프로세스 간의 부드러운 전환이 이루어지며, CPU 가상화가 완성되는 것이다. 결국 **제한적 직접 실행**이란, 기본적으로는 프로그램을 CPU에서 직접 돌려 성능을 확보하되, **모드 전환**과 **타이머 인터럽트**라는 하드웨어의 도움을 받아 제어권을 유지하는 운영체제의 영리한 실행 원리이다.
------
## 1. 목적
* **프로그램을 최대한 빠르게 직접 실행**시키면서도
* **CPU·메모리·디스크에 대한 최종 통제권은 OS가 유지**하려는 기법이 바로 **제한적 직접 실행(LDE)**이다.

## 2. 문제
1. **직접 실행만 사용하면**
    * 프로세스가 디스크, 메모리 등 **특권 연산을 마음대로 수행**할 수 있어서 위험하다.
2. **한 프로세스가 계속 돌고 있으면**
    * OS가 **CPU를 되찾아서 다른 프로세스로 바꿀 방법이 없다**는 문제가 있다.

## 3. 해결 방법
### (1) 특권 연산 통제
* **사용자 모드 / 커널 모드**로 권한을 나눈다.
* 프로세스는 **시스템 콜 + `trap`** 으로만 커널에 들어갈 수 있고,
* 하드웨어는 **트랩 테이블, 커널 스택**을 사용해 OS 코드로만 안전하게 분기하게 한다.
### (2) 프로세스 전환 및 시분할
* **옛날:** 프로세스가 I/O나 `yield` 시스템 콜로 **자발적으로 CPU를 양보**하는 협조 방식이었다.
* **현대:** **타이머 인터럽트**로 OS가 **주기적으로 강제로 개입**하여
    * **문맥 교환(context switch)** 을 수행하고
    * **PCB, 커널 스택**을 통해 A의 상태를 저장하고 B의 상태를 복원하여 시분할을 구현한다.

## 4. 남은 문제
* 시스템 콜 처리 중 인터럽트, 여러 인터럽트 중첩, 멀티코어 등으로 **커널 내부 병행성 문제**가 생긴다.
* 이를 해결하기 위해 **인터럽트 비활성화, 락(lock) 등 동기화 기법**을 사용해 커널 자료구조를 안전하게 보호해야 한다.
