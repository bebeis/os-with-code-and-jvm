# 7. 프로세스의 개념
#OS/OSTEP/이론/가상화

**프로세스**: 실행 중인 프로그램
- **프로그램**: 디스크 상에 존재하며 실행을 위한 명령어와 정적 데이터의 묶음
- 운영체제는 명령어와 데이터 묶음을 읽고 실행한다.

**CPU 가상화**: 하나 이상의 프로그램을 동시에 실행시키는 것
- 사용자가 사용 가능한 CPU의 유무를 신경쓰지 않고 여러 프로그램을 실행시키게 한다.
- 하나의 프로세스를 실행시키고, 얼마 후 중단시키고 다른 프로세스를 실행하는 작업을 반복하여 가능케 한다.
    - 이를 **시분할(timesharing)** 기법이라 한다.
        - 원하는 수 만큼의 프로세스를 동시에 실행하게 해준다.
        - 각 프로세스의 성능은 낮아진다.

**CPU 가상화는 어떻게 구현해야 할까?**
- 구현하기 위해서는 저수준의 도구인 **메커니즘**, 고차원적인 **지능**이 필요하다.
    - 메커니즘은 기능을 구현하는 **방법, 규칙**을 의미한다.
        - CPU 가상화 기능은 **컨텍스트 스위칭**을 통해 구현한다.
    - 운영체제의 지능은 **정책(policy)** 형태로 표현된다.
        - 정책: 어떤 결정을 내리기 위한 알고리즘이다.
        - ex) **스케줄링 정책**: 실행 가능한 여러 프로그램들이 있으면 OS는 어떤 프로그램을 실행시켜야 하는가?

> **공간 분할(space sharing)**
> 시분할과 대응되는 개념으로 공간 분할이 존재한다. 개체에게 공간을 분할해주는 것이다.
> 공간 분할의 예로는 디스크가 존재한다. 디스크는 자연스럽게 공간 분할할 수 있는 자원으로, 블럭이 하나의 파일에 할당되면 그 파일이 삭제되기 전 까지 다른 파일이 할당될 가능성은 낮다.


## 7.1 프로세스의 개념
“운영체제는 명령어와 데이터 묶음을 읽고 실행한다” 라고 했다. 즉, **운영체제는 “프로그램 실행”이라는 개념을 제공한다.**
- 특정 순간의 프로세스를 표현하려면 **접근했거나 영향을 받은 자원의 목록**을 작성하면 된다.
    - 쉽게 말하면 프로그램의 실행이라는 개념은, 그 순간 실행을 이어가는 데 필요한 모든 정보를 모아놓은 것이다.
- 프로세스의 구성 요소를 이해하기 위해서는 **하드웨어 상태**를 이해해야 한다.
    - 프로그램 실행 중에는 하드웨어 자원이 영향 받기 때문이다.

**하드웨어의 실행 상태** 중 가장 중요한 구성 요소는 **메모리**이다.
- 명령어는 메모리에 저장된다.
- 실행 프로그램이 읽고 쓰는 데이터도 메모리에 저장된다.
- 프로세스가 접근할 수 있는 메모리**(주소 공간)**은 프로세스를 구성하는 요소이다.

**레지스터**도 프로세스의 하드웨어 상태를 구성하는 요소 중 하나이다.
- 많은 명령어들이 레지스터를 직접 읽거나 갱신하기 때문이다.
    - ex) **프로그램 카운터(PC)**: 프로그램의 어느 명령어가 실행 중인지 알려줌
    - ex) **스택 포인터**, **프레임 포인터(frame pointer)**: 함수의 변수와 리턴 주소를 저장하는 스택을 관리할 때 사용하는 레지스터

**영구 저장장치(persistent stroage)**도 프로세스의 구성 요소이다.

> [!NOTE] OS에서 공통된 설계 패러다임: 정책과 구현의 분리
> 많은 OS에서 고수준 정책을 저수준 기법으로 분리하는 설계 패러다임을 사용한다.
> - 기법: “어떻게?”
> - 정책: “어느 것”? (ex. 어느 프로세스를 실행해?)
    > **정책과 기법을 분리**하면, 정책을 변경할 때 기법의 변경을 고민하지 않아도 된다. **모듈성**의 한 형태이다.

## 7.2 프로세스 API
**운영체제가 반드시 제공해야 하는 몇몇 기본 기능(인터페이스)**
- 생성(Create): 새로운 프로세스를 생성할 수 있는 방법을 제공해야 한다.
- 제거(Destroy): 프로세스를 강제로 제거할 수 있는 인터페이스를 제공해야 한다.
- 대기(Wait): 어떤 프로세스의 실행 중지를 기다릴 필요가 있기 때문에 여러 종류의 대기 인터페이스가 제공된다.
- 각종 제어(Miscellaneous Control): ex) 프로세스 일시 정지, 다시 시작 기능
- 상태(Status): 프로세스 상태 정보를 얻어내는 인터페이스

## 7.3 프로세스 생성 : 좀 더 자세하게
앞에서는 **운영체제는 “프로그램 실행”이라는 개념을 어떻게 제공할까?** 에 대해, “영향을 받은 자원의 목록” 관점에서 살펴봤다.

결국에는 프로그램에 작성되어 있는 내용을 바탕으로 자원에 접근할 텐데, 그렇다면 구체적으로 어떻게 자원에 접근하고 영향을 줄까?
(이를 고수준으로 표현하면, “프로그램이 어떻게 프로세스로 변형될까?”)
![](img/image.png)<!-- {"width":474} -->
프로그램 실행을 위해, 운영체제는 다음과 같은 작업을 진행한다.

첫 번째, 프로그램 코드와 정적 데이터(static data)를 메모리, 프로세스의 주소 공간에 **탑재(load)**한다.
- 운영체제는 디스크의 해당 바이트를 읽어서 메모리의 어딘가에 저장해야 한다.
- 초기 운영체제들은 프로그램 실행 전에 코드와 데이터를 모두 탑재하였지만, **현대 운영체제들은 프로그램을 실행하면서 코드나 데이터가 필요할 때 필요한 부분만 메모리에 탑재한다.**
    - **페이징**과 **스와핑**을 통해 동작한다. 페이징과 스와핑에 대한 자세한 내용은 뒤에서 다룬다.

코드, 정적 데이터 탑재 이후 운영체제는 몇 가지 일을 추가적으로 수행한다.
1. 일정량의 메모리가 프로그램의 **런타임 스택** 용도로 할당된다. (스택 메모리 할당)
    - 지역 변수, 함수 인자, 리턴 주소 등을 저장하는데 사용되는 런타임 스택을 할당한다.
    - 실행 시점에서는 main() 함수의 인자를 사용하겠죠?
2. 프로그램의 **힙(heap)**을 위한 메모리 영역을 할당한다.
    - 동적으로 할당된 데이터를 저장하기 위해 사용되는 영역이다.
    - 힙은 연결 리스트, 해시 테이블, 트리 등 크기가 가변적인 자료 구조를 위해 사용된다.
    - malloc()과 free()
3. 입출력과 관계된 초기화 작업을 수행한다.
    - UNIX에서 각 프로세스는 STDIN, STDOUT, STDERR 장치에 해당하는 세 개의 파일 디스크립터를 갖는다.
    - 프로그램은 이 디스크립터를 사용하여 데이터 입력을 읽고 출력한다.

이렇게 작업을 마치게 되면 운영체제는 프로그램 실행을 위한 준비를 마치게 된다. 이제, 프로그램의 entry point(시작 지점, `main()`)부터 프로그램을 시작한다. 운영체제는 CPU를 새로 생성된 프로세스에게 넘기게 되고 프로그램 실행이 시작된다.


> Question)
> 자바에서는 크기가 가변적인 자료 구조를 포인터 이런거로 신경쓰지 않고 만든다.
> **static 필드에 만들기도 하는데, static 필드의 가변 자료구조는 어느 곳에 저장될까?**
>
> Answer)
> **static(클래스) 변수**(즉 클래스에 소속된 필드들)는 JVM 사양상 **메서드 영역(method area)**(클래스 메타데이터 영역)에 속한다.
> - 실제 구현(예: HotSpot)에서는 이 메서드 영역이 **Metaspace(네이티브 메모리)**로 구현되며, static 변수의 참조값은 이 영역에 저장된다.
> - 하지만 static 변수의 **참조가 가리키는 객체 자체는 힙에 존재**한다.
> ```java
> public class A {
>     static List<String> list = new ArrayList<>();
>     int id;
>     public void foo() {
>         String s = "hello";
>         A a = new A();
>     }
> }
> ```
> - `new ArrayList<>()` → `ArrayList` 객체와 내부 `Object[] elementData`는 **힙**에 할당된다.
> - `list`의 참조값은 메서드 영역(구현상 Metaspace의 클래스 데이터)에 위치한다.
    > ![](img/url.png)<!-- {"width":303} -->
    > ![](img/image%207.png)
    > ![](img/image%206.png)
> - **낮은 주소** 쪽은 보통 **Heap 시작점**
> - **높은 주소** 쪽은 **Stack 시작점**

## 7.4 프로세스 상태
프로세스가 생성되는 과정을 대충 봤으므로, 프로세스의 상태에 대해서도 간략히 살펴보자.

프로세스의 상태를 단순화하면, 프로세스는 다음 세 상태 중 하나에 존재한다고 할 수 있다.
- 실행(Running): 프로세서 실행 중인 프로세스. 즉 명령어를 실행하고 있다.
- 준비(Ready): 실행할 준비가 되어 있지만, 운영체제가 다른 프로세스를 실행하고 있는 등의 이유로 대기 중이다.
- 대기(Blocked): 프로세스가 다른 사건을 기다리는 동안 프로세스의 수행을 중단시키는 연산
    - ex) 디스크 I/O 완료 될 때 까지 대기 상태가 되고, 다른 프로세스가 실행 상태가 된다.

![](img/image%202.png)<!-- {"width":400} -->
- 프로세스는 준비 상태와 실행 상태를 운영체제의 정책에 따라 이동한다.
    - 스케줄이 되면 준비 상태에서 실행 상태로 전이한다.
    - 실행 상태에서 준비 상태로의 전이는 프로세스가 나중에 다시 스케줄 될 수 있는 상태가 되었다는 것을 의미한다.
- 프로세스가 입출력 요청 등의 이유로 대기 상태가 되면 요청 완료 등의 이벤트가 발생할 때 까지 대기 상태로 유지된다.
    - 이벤트가 발생하면 프로세스는 다시 준비 상태로 전이되고, 운영체제의 결정에 따라 바로 다시 실행될 수도 있다.

![](img/image%203.png)<!-- {"width":546} -->
![](img/image%204.png)<!-- {"width":717} -->
- 그림 7.4를 자세히 보면, `Process0`는 입출력을 요청하여 요청한 작업이 완료되기를 기다린다.
- 프로세스는 디스크를 읽거나 네트워크로부터 패킷을 기다릴 때 대기 상태로 전이한다. -> 운영체제는 `Process0`가 CPU를 사용하지 않는다는 것을 감지하고 `Process1`을 실행시킨다.
- `Process1`이 실행되는 동안 입출력은 완료되고 `Process0`는 준비 상태로 다시 전인된다.
- `Process1`이 종료되고 난 후 `Process0`가 실행되어 종료된다.

여기서 주목해야 하는 것이 몇 가지 있다.
- `Process0`이 입출력을 요청할 때 `Process1`의 실행여부를 결정해야 한다.
    - `Process1`을 실행하기로 결정하면서 자원 이용률을 높인다.
- `Process0`이 요청한 입출력이 완료되었을 때, `Process0`을 바로 실행하지 않고 실행중이던 `Process1`을 계속 실행했다.
    - 이게 좋은 결정인지는 확실치 않다. 운영체제는 스케줄러를 따라 결정을 내린다.

> [!NOTE] 자료 구조 - 프로세스 리스트
> OS에도 다양한 자료 구조들이 존재한다.
> - `프로세스 리스트`를 이용하여 시스템에서 실행 중인 프로그램을 관리한다.
> - 프로세스의 관리를 위한 정보를 저장하는 자료구조를 **프로세스 제어 블록(Process Control Block, PCB)**라 부른다.

## 7.5 자료 구조
운영체제도 프로그램이기 때문에, 다양한 정보를 유지하기 위한 자료 구조를 가지고 있는다.
- 준비 상태의 프로세스를 위한 프로세스 리스트
- 실행 중인 프로세스를 위한 자료구조
- 대기 상태인 프로세스를 위한 자료구조
    - 입출력 요청이 완료되면 깨워서 준비 상태로 전이시켜야 하니까

![](img/image%205.png)<!-- {"width":532} -->
- 각 프로세스를 추적하기 위해 운영체제가 필요로하는 정보이다.
- 운영체제가 관리하고 있는 프로세스 정보를 알 수 있다.
    - **레지스터 문맥(register context)** 자료구조는 프로세스가 중단되었을 때 해당 프로세스의 레지스터 값들을 저장한다.
    - 이 레지스터 값을 복원하여 프로세스 실행을 재개한다.
- 실행, 준비, 대기 외에도 다른 상태들이 존재한다.
    - 프로세스가 생성되는 동안에는 `초기(initial) 상태`에 머무른다.
        - 유닉스 기반 시스템에서는 `zombie` 상태라고 부른다.
    - 프로세스는 종료되었지만 메모리에 남아있는 상태인 `최종(final) 상태`도 있다. 이 상태는 프로세스가 성공적으로 실행했는지를 다른 프로세스가 검사하는데 유용하다.
        - ex) 부모 프로세스는 자식 프로세스의 대기하는 시스템 콜을 호출한다.(ex. `wait()`) 이 때, 최종 상태를 활용한다. 프로세스가 성공적으로 종료되면 0을, 아니면 0이 아닌 값을 반환하므로 이 값을 이용한다.

> **Q) 자바에도 `.join()` `wait()`, `notify()` 같은 메서드들이 있다. 이러한 메서드를 사용하면 내부적으로 어떻게 Syscall을 하게될까?**
>
> A)
> 1. **Java 코드**에서 wait() / notify() / join() 호출
> 2. **JVM 런타임** (C/C++ 네이티브 코드로 구현)으로 진입
> 3. **OS 스레드 API / syscall** 호출 (플랫폼별로 다름)
> 4. **커널 스케줄러**가 해당 스레드를 **BLOCKED / WAITING / TIMED_WAITING → RUNNABLE** 상태로 전환
     > 중요한 건, 바로 syscall을 하지는 않는다는 것이다. JVM은 먼저 사용자 공간에서 CAS, 스핀락 등으로 해결하려고 하고, 진짜로 “잠들어야” 하는 순간에만 커널 syscall로 넘어간다.
     > synchronized 같은 락 진입은 **대부분 syscall 없이 처리**되고, wait()/join()처럼 **스레드 상태 전환이 필요한 경우**에만 OS와 직접 상호작용한다.

