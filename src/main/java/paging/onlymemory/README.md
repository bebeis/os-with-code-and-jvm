# 21. 페이징: 개요
#OS/OSTEP/이론/가상화

**운영체제**는 공간 관리 문제를 해결할 때는 두 가지 방법 중 하나를 사용한다.
1. 가상 메모리의 세그멘테이션과 같이, 가변 크기의 조각들로 분할한다.
   - 공간을 다양한 크기의 청크로 분할 할 때 공간 자체가 **단편화되어 할당이 어려워진다.**
2. 공간을 동일 크기의 조각으로 분할한다.
   - 가상 메모리에서 이 방법을 **페이징**이라고 부른다.

이번 챕터부터는 **페이징**에 대해 자세히 알아본다.
- 페이징은 세그멘테이션처럼 **프로세스의 주소 공간**을 몇 개의 **가변 크기의 논리 세그먼트로 바꾸는 것이 아니라, 고정 크기의 단위로 나눈다.**
  - 스택/힙/코드 이렇게 가변적인 논리 세그먼트로 바꾸는 것이 아니다.
  - 이 각각의 고정 크기 단위를 **페이지**라고 부른다.
- **물리 메모리도** **페이지 프레임**이라고 불리는 **고정 크기의 슬롯 배열로 간주**한다.
![](21.%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD/image.png)<!-- {"width":645} -->
- 프레임 각각은 하나의 가상 메모리 페이지를 저장할 수 있다.

앞으로 **어떻게** 메모리를 페이지를 사용하여 가상화할 수 있는지, 그리고 **어떤 기법**을 통해 공간과 시간 **오버헤드를 최소화**하면서 구현해낼건지를 살펴보게 된다.

## 21.1 간단한 예제 및 개요
**주소 공간**
![](21.%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD/image%202.png)<!-- {"width":409} -->
- 총 크기가 64바이트이면서, 4개의 16바이트 페이지로 구성된 작은 주소 공간이다.

**물리 메모리**
![](21.%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD/image%203.png)<!-- {"width":584} -->
- **물리 메모리**는 **고정 크기의 슬롯**들로 구성된다.
- 가상 주소 공간의 페이지는 물리 메모리 전체에 분산 배치된다.
- 운영체제가 자기자신을 위해서 물리 메모리 일부를 예약하고 사용한다.

### 페이징의 장점
**유연성**
- 프로세스의 주소 공간 사용 방식과는 상관없이 효율적으로 주소 공간 개념을 지원할 수 있다.
  - ex) 힙과 스택이 어느방향으로 커지는지, 어떻게 사용되는지 가정하지 않아도 된다.

**단순함**
- 위 예제에서 64바이트 주소공간을 물리 메모리에 탑재하기 위해선, 16바이트짜리 비어있는 네 개의 페이지만 찾으면 된다.
- 운영체제는 free list를 유지하고 리스트의 첫 네 페이지를 선택할 것이다. 단순하다.

### 페이지 테이블
페이징을 통해 주소 공간의 페이지가 물리 메모리 프레임에 저장되는 건 알겠다. 그렇다면, **주소 공간의 각 페이지가 어떤 물리 메모리에 위치**하는지는 어떻게 알 수 있을까? 

운영체제는 프로세스마다 **페이지 테이블(page table)**이라는 자료 구조를 유지한다. 
- 페이지 테이블은 주소 공간의 가상 페이지 **주소 변환 정보를 저장**한다.
- 각 페이지가 저장된 물리 메모리 위치가 어디인지 알려준다.
- 위 예시에서는 VP 0 -> PF 3, VP 1-> PF 7, …

페이지 테이블은 **프로세스마다 존재**한다. (**역 페이지 테이블** 같은 기법도 있긴 하다.)
운영체제는 다른 프로세스는 다른 물리 페이지에 존재할 것이고, 결국 다른 프로세스를 실행하기 위해선 **다른 페이지 테이블**이 필요하다. 

### 페이지 테이블을 통한 주소 변환 예시
`movl <virtual address>, %eax` -> virtual address에 있는 데이터를 eax 레지스터에 탑재해야 한다

값을 얻어오려면 실제 물리 메모리까지 접근해야 하고, 결국 virtual address를 변환해야 한다.
가상 주소의 **변환**을 위해, 먼저 가상 주소를 **가상 페이지 번호(virtual page number, VPN)**와 페이지 내의 **오프셋** 2개의 구성 요소로 분할한다. 
![](21.%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD/image%204.png)<!-- {"width":381} -->
- 이 예시에선 주소 공간의 크기가 64바이트이다. 가상 주소는 6비트가 필요하다 (2^6)
- 우리는 16바이트 페이지 크기로 4개가 구성된다는 것을 알고 있다. 따라서 4개의 페이지를 선택할 수 있어야하고 **최상위 2비트가 그 역할을 한다. (VPN)**
- **나머지 비트**는 **페이지 내에서** 우리가 원하는 바이트 위치를 나타낸다 **(= 오프셋)**

프로세스가 가상 주소를 생성하면 **운영체제와 하드웨어**가 의미있는 물리 주소로 변환한다. 만약 가상 주소가 21이라고해보자.
- `010101`
  - VPN: `01`
  - OFFSET = `0101`
- 1번 페이지의 5번째 바이트

여기서 1번 페이지는 주소 공간 상의 페이지 번호이다. 우리는 **이 페이지 번호를 바탕으로 어느 물리 프레임에 저장**되어 있는지 찾아야 한다. 이 때 **페이지 테이블**을 이용하여 **물리 프레임 번호(physical frame number, PFN)** 또는 **물리 페이지 번호(PPN)**을 얻는다.
![](21.%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD/image%205.png)<!-- {"width":540} -->
- 페이지 테이블을 통해 VPN을 PFN(111)로 교체했다.
- 물리 주소를 얻었으므로 물리 메모리 탑재 명렁어를 실행한다.
- 주소 공간의 오프셋과 물리 메모리 상의 오프셋은 동일하다.

> [!NOTE] 참고) VPN / Offset을 나눈 이유
> **고정된 크기의 블록**으로 나누어 관리하기 위함이다. 고정된 크기로 관리하기 위해선 **해당 블록이 몇 번째** 인지를 알아야하고, **블록 내에서도 어디에 위치**하는지 알아야 한다. 따라서 VPN과 OFFSET으로 나뉘어진다. (사실 너무나도 자연스러운 것이긴 하다)

> [!NOTE] 참고) 만약 페이지 크기가 커진다면?
> - 내부 단편화는 심해진다.
> - 디스크 I/O 양이 많아져 오버헤드가 증가한다.
> - 페이지 수가 줄어들어 페이지 테이블의 크기가 줄어든다.
> - 뒤에서 배우겠지만 TLB 효율이 증가한다.
> 페이지 크기가 작아진다면 이것의 반대이다.
> OS가 수십 년 동안 트레이드 오프를 고민해서 얻은 페이지 크기가 4KB이다.

> [!NOTE] 참고) 물리 페이지 프레임 크기와, 주소 공간의 페이지 크기가 동일해야 하는 이유
> 여러가지 이유가 있지만, **주소 변환(virtual → physical)이 단순한 덧셈으로 가능해야 하기 때문이다.** 프레임 크기와 페이지 크기가 동일하기 때문에, offset 값을 가상/물리 공간에서 동일하게 사용할 수 있다.
> 하지만 크기가 달라진다면, **offset의 범위가 달라지고 처리 방식이 복잡해진다.** “테이블” 기반의 처리 방식이 불가능할 수도 있고, 보호/격리 등이 어려워질 수도 있다. 

## 21.2 페이지 테이블은 어디에 저장될까?
페이지 테이블은 매우 커질 수 있다. 일반적인 4KB 크기의 페이지를 갖는 32비트 주소 공간을 생각해보자. 
- 4KB 페이지의 오프셋을 위한 2^12 즉, 12비트 오프셋이 필요하고 20비트를 VPN으로 사용한다. 
- 각 프로세스를 위해 관리해야 하는 변환의 개수가 2^20개이다.
- 물리 주소 변환 정보 및 기타 필요한 정보를 위한 **페이지 테이블 항목(page table entry, PTE)** 하나가 4바이트 필요하다고 가정하면, 프로세스마다 4MB 메모리가 필요해진다.
- 만약 프로세스가 100개 실행중이라면, 운영체제가 400MB 메모리를 필요로 한다.

메모리 변환을 위해 이런 큰 청크를 사용하는 것은 매우 비정상적이다. 실제론 이렇게 비효율적으로 구현되지는 않는다. 실제론 운영체제 메모리의 많은 부분이 가상화되고 디스크에서 스왑된다. **하지만 이번 챕터에선 페이지 테이블은 운영체제가 관리하는 메모리에 상주한다고 가정한다.**

## 21.3 페이지 테이블에는 실제 무엇이 있는가
페이지 테이블은 VPN(가상 페이지 번호)을 PFN(물리 프레임 번호)로 매핑하는데 사용되는 자료구조이다.
가장 간단한 형태는 단순한 배열 형태의 **선형 페이지 테이블**이다. 가상 페이지 번호로 배열의 항목에 접근하고 검색한다. 이번 챕터에선 선형 페이지 테이블을 가정한다.

![](21.%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD/image%206.png)<!-- {"width":611} -->
**PTE**에는 여러 비트가 함께 존재한다.
![](21.%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD/image%207.png)
- **valid bit**: 특정 변환의 유효 여부를 나타냄
  - 주소 공간 상의 힙-스택 사이 미사용 공간은 **무효(invalid)**로 표시되고, 접근 시 OS에 트랩을 발생시킴
  - 할당되지 않은 주소 공간을 표현하기 위해 반드시 필요함.
- **protection bit**: 페이지가 읽을 수 있는지, 쓸 수 있는지, 실행될 수 있는지를 표시
- **present bit**: 이 페이지가 물리 메모리에 있는지, 혹은 디스크에 있는지를 가리킨다.
  - 뒷 챕터에서 스왑과 스왑 아웃에 대해 배울텐데, **스왑 아웃**되었는지를 나타낸다. 스왑은 간단하게 설명하자면, 드물게 사용되는 페이지를 디스크로 이동시켜 물리 메모리를 비워주는 기법이다.
- **dirty bit**: 메모리에 반입된 후 페이지가 변경되었는지 여부를 나타낸다.
- **reference bit(access bit)**은 페이지가 접근되었는지 추적하기 위해 사용된다. **페이지 교체** 시, 어떤 페이지가 인기있는지 결정하여 메모리에 유지할 지 말지를 결정하는데, 이 때 이 비트는 매우 중요하다.
- 이외에도 여러 비트가 있다.

## 21.4 페이징: 너무 느림
페이지 테이블의 크기가 메모리 상에서 증가하게 되면, 처리 속도가 저하되게 된다. 그 이유를 예를 통해 확인해보자.

### **예시: `movl 21 %eax`**
원하는 데이터를 가져오기 위해 가상 주소(21)를 물리 주소(117)로 변환해야 한다. 물리 메모리에서 데이터를 반입하기 전에 시스템은 프로세스의 페이지 테이블에서 **적절한 페이지 항목을 가져와야 하고,** 변환을 수행하고 물리 메모리에서 데이터를 탑재한다.

이렇게 하기 위해선 **현재 실행 중인 프로세스의 페이지 테이블 위치**를 알아야 한다. **페이지 테이블 베이스 레지스터**라는게 있어서 여기서 페이지 테이블의 시작 주소를 저장한다고 **가정**하자.

```python
VPN = (VirtualAddress & VPN_MASK) >> SHIFT
PTEAddr = PageTableBaseRegister + (VPN * sizeof(PTE))
```
- 이 예제에서 VPN_MASK는 0x30(110000)으로 설정되고,  마스킹하면 VPN 비트만 골라낸다. 그리고 하위 4비트(SHIFT)를 오른쪽으로 이동시키면 VPN만 남는다.
- `01`은 PTE 배열에 대한 인덱스로 사용된다.
- 테이블 베이스 레지스터 주소가 알려지면 하드웨어는 메모리에서 PTE를 반입하고, PFN을 추출하여 원하는 물리 주소를 만든다.

```
offset = VirtualAddress & OFFSET_MASK
PhysAddr = (PFN << SHIFT) | offset
```

### 각 메모리 참조 시 일어나는 **세부 동작**
**모든 메모리 참조에 대해(명령어 반입, load, store …)** 먼저 페이지 테이블에서 변환 정보를 반입해야 하기에, 반드시 **한 번의 추가적인 메모리 참조가 필요하다.** 메모리 참조는 비용이 비싸므로 2배 이상 느려진다.
![](21.%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD/image%208.png)
페이지 테이블로 인해 시스템이 매우 느려질 수 있고, 너무 많은 메모리를 차지할 수 있다는 것을 알았다. 우리는 이 두 문제를 해결해야 한다.

## 21.5 메모리 트레이스
페이징을 사용했을 때 발생하는 모든 메모리 접근을 분석해보자.

**예시: array.c**
```c
int array[1000];
for (int i = 0; i < 1000; i++) 
	array[i] = 0;
```

![](21.%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD/image%209.png)<!-- {"width":655} -->
- 첫 번째 명령어는 값 `0`을 가상 메모리 주소로 옮긴다.
  - `%edi`는 배열의 시작 주소
  - `%eax`는 배열 인덱스를 저장한다.
  - 정수니까 4를 곱한다.
- 두 번재 명령어는 `%eax`에 저장된 배열 인덱스를 증가시킨다.
- 세 번째 명령어는 `%eax` 값과 십진수 1000을 비교한다. 
- 네 번째 명령어는 루프의 상단으로 다시 분기한다.

명령어 시퀀스들이 어떤 메모리 접근을 생성하는지 파악하기 전에, **코드와 배열의 가상 메모리 주소와 페이지 테이블의 위치에 대해 몇 가지 가정을 하자.**
- 64KB 주소 공간, 페이지 크기는 1KB로 가정한다.
- 선형 페이지 테이블이고 물리 주소 1KB에 위치한다고 가정한다.

이 예시에서 신경 써야 할 몇 개의 페이지 테이블의 페이지는 다음과 같다.
1. 코드가 상주하는 가상 페이지
2. 배열 자체

**프로그램의 메모리 참조를 살펴보자.** 각 명령어 반입시에 메모리가 두 번 참조한다는 점을 명시하고 보자.
1. 명렁어의 위치를 파악하기 위해 페이지 테이블 접근 한 번 / 명령어 자체에 한 번
2. mov 명령어는 메모리 참조를 한 번 / 명령어 자체에 한 번
3. 배열 자체에 접근하기 위해 한 번

![](21.%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD/image%2010.png)<!-- {"width":663} -->
- 루프당 10번의 메모리 접근이 존재한다.
  - 네 번의 명령어 반입
  - 한 번의 메모리 갱신
  - 다섯 번의 페이지 테이블 접근

## 21.6 요약
페이징은 이전 방식에 비해 많은 장점을 가지고 있다. 메모리를 고정 크기 단위로 나누고, 가상 주소 공간의 드문 사용을 허용한다.
허나, 페이징을 제대로 구현하지 못하면 컴퓨터가 매우 느려지고 메모리 낭비까지 초래한다. 제대로 된 동작엔 더 많은 노력이 필요하다.

## 구현 코드 실행 결과
```
virtualAddress 21 을 물리 주소로 변환 시도
virtualAddress = 21, physicalAddress = 117

write false 페이지에 쓰기 시도 시 트랩 발생
Expected trap: Trap: write to read-only page
```

# 깔끔하게 요약
## 1. 기술의 목적: 왜 페이징인가?
운영체제가 메모리 공간을 관리할 때 가장 큰 문제는 **단편화(Fragmentation)**와 **관리의 복잡성**이다.
* **기존 문제 (세그멘테이션):** 가변 크기의 청크(Chunk)로 메모리를 나누면, 빈 공간이 불규칙하게 흩어져 할당이 어려워진다.
* **해결책 (페이징):** 공간을 **고정된 크기(Fixed size)**의 단위로 나누어 관리한다. 이를 통해 물리 메모리의 빈 공간 관리 문제를 단순화하고 유연성을 확보한다.

## 2. 핵심 동작 원리
페이징 시스템은 가상 메모리와 물리 메모리를 동일한 크기의 조각으로 나누어 매핑한다.

**1) 기본 용어**
* **페이지(Page):** 가상 메모리(프로세스의 주소 공간)를 나눈 고정 크기 블록이다.
* **페이지 프레임(Page Frame):** 물리 메모리를 나눈 고정 크기 슬롯이다. 하나의 프레임은 하나의 페이지를 저장한다.

**2) 주소 변환 (Address Translation)**
가상 주소는 **VPN(가상 페이지 번호)**과 **Offset(오프셋)**으로 분할된다.
* **VPN:** 해당 주소가 '몇 번째 페이지'에 있는지를 나타낸다. 이를 통해 물리 프레임 번호(PFN)를 찾는다.
* **Offset:** 페이지 내에서 정확히 '어떤 위치'에 있는지를 나타낸다. 가상 주소와 물리 주소에서 동일하게 유지된다.

**3) 페이지 테이블 (Page Table)**
가상 주소를 물리 주소로 변환하기 위한 **매핑 정보**를 담은 자료구조이다.
* **구조:** 프로세스마다 존재하며, VPN을 인덱스로 사용하여 **PFN(물리 프레임 번호)**을 반환한다.
* **PTE (Page Table Entry):** 변환 정보 외에도 시스템 관리를 위한 비트들을 포함한다.
  * **Valid Bit:** 변환의 유효 여부 (사용되지 않는 공간 접근 시 트랩 발생).
  * **Protection Bit:** 읽기/쓰기/실행 권한.
  * **Present Bit:** 물리 메모리에 존재하는지, 디스크(스왑)에 있는지 표시.
  * **Dirty Bit:** 페이지 변경 여부.
  * **Reference Bit:** 페이지 접근 여부 (페이지 교체 알고리즘에 사용).

## 3. 페이징의 장점: 문제 해결
* **유연성(Flexibility):** 프로세스가 주소 공간(스택, 힙 등)을 어떻게 사용하는지 가정할 필요가 없다.
* **단순함(Simplicity):** 물리 메모리 할당 시, 빈 페이지 프레임 리스트(Free List)에서 필요한 개수만큼 꺼내주기만 하면 된다. 복잡한 적합 알고리즘이 필요 없다.

## 4. 남은 문제점: 페이징의 비용
단순하고 유연한 방식이지만, 구현 시 두 가지 큰 **오버헤드**가 발생한다.

**1) 속도 저하 (Time Overhead)**
* 메모리 참조 시마다 페이지 테이블을 먼저 읽어야 하므로, **최소 1번의 추가 메모리 접근**이 발생한다.
* 예: 명령어 반입, 데이터 로드/스토어 등 모든 작업에서 메모리 접근 횟수가 2배 이상 늘어나 시스템이 현저히 느려진다.

**2) 공간 낭비 (Space Overhead)**
* 페이지 테이블 자체가 메모리에 상주해야 한다.
* 32비트 주소 공간, 4KB 페이지 크기를 가정할 때, 프로세스당 약 **4MB**의 페이지 테이블이 필요하다. 프로세스가 100개라면 400MB가 필요하므로 메모리 소모가 매우 크다.
