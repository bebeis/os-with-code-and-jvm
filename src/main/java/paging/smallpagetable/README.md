# 23. 페이징: 더 작은 테이블
#OS/OSTEP/이론/가상화

이전 챕터에서는 페이징의 문제점 중 하나인 “속도” 문제를 해결하였다. 이번 챕터에서는 남은 문제점 하나인 페이지 테이블의 **“크기”** 문제를 해결한다.

페이지 테이블이 크면 많은 메모리 공간을 차지한다. 32비트 주소 공간의 페이지 크기가 4KB인 일반적인 체계에서, PTE 항목이 4바이트라면, 프로세스당 페이지 테이블은 4MB이다. 100개 프로세스라면 400MB가 된다.

이런 단순 배열 기반 페이지 테이블은 메모리를 과도하게 차지한다. 어떻게 페이지 테이블의 크기를 줄일 수 있을까?

## 23.1 간단한 해법: 더 큰 페이지
페이지 테이블은 매핑 정보를 담는 거다. 페이지 수 자체가 줄면 페이지 테이블 크기가 줄어든다. 즉, 페이지 크기를 증가시켜버린다.
4KB 대신 16KB로 페이지 크기를 키우면, 18비트 VPN과 14비트 OFFSET을 갖게 된다.

페이지 개수가 1/4가 되므로, 기존 페이지 테이블 대비 크기가 1/4로 감소된다.

**부작용**
문제는 페이지 내부 공간이 증가하여 내부 단편화가 발생한다는 것이다. 
페이지 할당 받은 걸 다 쓰질 않는데, 여기서 크기를 더 키우면 내부 단편화는 심해진다.
결국 메모리 낭비는 심해지고 메모리가 금방 고갈된다.

결론적으로, 페이지 크기는 키우기 어렵다. 작아야 한다. (많은 OS에서도 4KB, 8KB 정도의 작은 페이지 크기를 유지한다.)

## 23.2 하이브리드 접근 방법: 페이징과 세그먼트
프로세스 주소 공간을 연속적으로 탑재하면 내부 단편화가 발생하기 때문에 세그멘테이션을 사용했고, 세그멘테이션으로 가상 공간의 메모리를 배치할 때 세그먼트의 외부 단편화 문제 때문에 페이징을 사용했다.

그리고 우리는 페이지의 크기는 유지하면서 페이지 테이블 크기를 줄여야 하는 입장이다. 한 번 **페이지 테이블**을 살펴보자.
![](23.%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%83%E1%85%A5%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%8B%E1%85%B3%E1%86%AB%20%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%86%AF/image.png)<!-- {"width":477} -->
- 1KB 크기의 페이지를 갖는 16KB 주소 공간이다.
- 한 개의 코드 페이지: VPN 0 -> PFN 10
- 두 개의 스택 페이지: VPN 14-> PFN 28, VPN 15 -> PFN 4
- 한 개의 힙 페이지: VPN 4-> PFN 23

페이지 테이블이 **대부분** 비어있다. **엄청난 낭비**가 발생한다. 
> 어? 공간 내부의 낭비? 내부 단편화랑 비슷한데… **페이지 테이블 자체**를 **스택/힙/코드 공간별로 나눠볼까?(세그멘테이션)**

- 기존: `프로세스의 전체 주소 공간 : Page Table = 1 : 1`
- 결합: `논리 세그먼트 : Page Table = 1 : 1`
  - 코드, 힙, 스택 세그멘트에 대해 페이지 테이블을 따로 배치한다.

세그멘테이션을 통한 메모리 할당 방식에서, **베이스/바운드(리미트) 레지스터**가 필요했다. 여기서도 비슷한 구조를 사용한다.
- 베이스 레지스터는 **해당 세그멘트의 페이지 테이블 시작 주소**를 갖는다.
- 바운드 레지스터는 페이지 테이블의 끝을 나타내기 위해 사용한다.

예를 들어, 4KB 페이지를 갖는 32비트 가상 주소 공간이 4개의 세그멘트로 나뉘어 있다고 가정하자. 세 개의 세그먼트만 사용한다고 해보자.
- 미사용 세그먼트: `00`
- 코드: `01`
- 힙: `10`
- 스택: `11`
![](23.%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%83%E1%85%A5%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%8B%E1%85%B3%E1%86%AB%20%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%86%AF/image%202.png)
하드웨어에는 세 개의 베이스/바운드 레지스터 쌍이 코드/힙/스택을 위해 존재한다고 가정한다.
- 각 세그먼트의 베이스 레지스터는 세그멘트의 페이지 테이블 시작 물리 주소를 갖는다.
- 모든 프로세스들은 세 개의 페이지 테이블을 갖는다.
- 문맥 교환 시, 이 레지스터들은 새로 실행되는 프로세스의 페이지 테이블의 위치 값을 변경된다.

페이징으로 물리 메모리 접근을 하는데 **TLB 미스**가 발생했다고 해보자.
- 페이지 테이블에 접근해야 한다.
- 페이지 테이블이 세그멘트별로 나뉘어져있으므로, 어떤 논리 세그멘트인지 알아야 한다.
- 하드웨어는 **세그멘트 비트**를 사용하여 **어떤 베이스와 바운드 쌍을 사용**할 지 결정할 수 있다.
  - 하드웨어 기반 TLB를 가정한다.
```c
SN = (VirtualAddress & SEG_MASK) >> SN_SHIFT
VPN = (VirtualAddress & VPN_MASK) >> VPN_SHIFT
AddressOfPTE = Base[SN] + (VPN * sizeof(PTE))
  ```
- 기존 방식과 거의 유사하다. 
- 페이지 테이블에 접근하는 방식이 `페이지 테이블 베이스 레지스터` -> `세 개 중의 하나의 세그멘트 베이스 레지스터`를 사용하는 것으로 바뀐 것 뿐이다.

각 **바운드 레지스터**의 값은 **세그멘트의 최대 유효 페이지의 개수**를 나타낸다. 범위를 넘어가는 곳에 대한 메모리 접근 예외를 발생시킨다.

하이브리드 기법은 스택과 힙 사이의 할당되지 않은 페이지들은 페이지 테이블 상에서 더 이상 공간을 차지 하지 않게 되어, 선형 페이지 테이블에 비해 메모리 사용을 개선할 수 있다.

하지만, 이 기법 역시 문제가 존재한다. **“페이지 테이블”에 대해 세그멘테이션을 적용하지만, 결국 세그멘테이션의 한계가 있다.**
- 세그멘테이션은 주소 공간 사용에 있어 특정 패턴을 가정하기 때문에 우리가 원하는 만큼 유연하지 못하다.
  - 드문드문 사용되는 힙의 경우 여전히 페이지 테이블의 낭비가 발생한다.
- 결국에는 각기 다른 크기의 페이지 테이블 여러 개를 메모리에 배치해야 한다. 페이지 테이블을 세그멘테이션하여 메모리에 배치한다? -> **앞에서 봤던 외부 단편화가 다시 발생한다.**
  - 메모리 상에서 페이지 테이블용 공간을 확보하는 것이 복잡해진다.

## 23.3 멀티 레벨 페이지 테이블
결국엔 페이지 테이블을 세그멘테이션하기 때문에, 세그멘테이션의 한계에 부딪힌다. 
> 어? 그러면 페이지 테이블도 페이징 비슷하게 하면 되지 않을까? -> **멀리 레벨 페이지 테이블**

**멀리 레벨 페이지 테이블**에서는 선형 페이지 테이블을 트리 구조로 표현한다. 매우 효율적이기 때문에 많은 현대 시스템에서 사용되고 있다.

### 기본 개념
먼저 페이지 테이블을 페이지 크기의 단위로 나눈다. 그 다음, 페이지 테이블의 페이지가 유효하지 않은 항목만으로 구성되면, 해당 페이지를 할당하지 않는다. **페이지 디렉터리(page directory)**라는 자료구조를 사용하여 페이지 테이블의 각 페이지의 할당 여부와 위치를 파악한다.

![](23.%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%83%E1%85%A5%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%8B%E1%85%B3%E1%86%AB%20%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%86%AF/image%203.png)<!-- {"width":633} -->
- 좌측 선형 페이지 테이블에서, 페이지 테이블의 중앙부 주소공간은 사용되고 있지 않다. 그러나 페이지 테이블의 가운데 두 페이지는 메모리에 할당되어 있다.
- 우측 멀티 레벨 페이지에서는, 두 개의 유효한 페이지가 있다. 두 개만 메모리에 존재한다. 선형 페이지에서 사용되던 가운데 2개의 페이지는 더 이상 필요없고, 페이지 디렉터리를 이용하여 페이지 테이블의 어떤 페이지들이 할당되어있는지 관리한다.

2단계 테이블에서, 페이지 디렉터리의 각 항목은 페이지 테이블의 한 페이지를 나타낸다. 
페이지 디렉터리의 각 항목을 **페이지 디렉터리 항목(page directory entires, PDE)**라고 하고, PTE와 유사하다. **유효(valid)** 비트와 **페이지 프레임 번호(PFN)**을 가지고 있다.
- PTE의 valid bit과 PDE의 valid bit은 약간 다르다. **PDE 항목이 유효**하다는 것은, 그 항목이 가리키고 있는 페이지들 **중 최소한 하나가 유효하다는 것을 의미한다.**
- PDE가 가리키고 있는 페이지 내의 최소한 하나의 PTE의 valid bit가 1로 설정되어 있다.

멀티 레벨 페이지가 지금까지 언급된 기법에 비하면 다음과 같은 장점이 있다.
- 사용된 주소 공간의 크기에 비례하여 페이지 테이블 공간이 할당된다. 
  - 보다 작은 크기의 페이지 테이블로 주소 공간을 표현할 수 있다.
- 페이지 테이블을 페이지 크기로 분할함으로써 메모리 관리가 매우 용이하다.
  - 페이지 테이블을 할당하거나 확장할 때, 운영체제는 free 페이지 풀에 있는 빈 페이지를 가져다 쓰면 된다.
  - 반면, 선형 페이지 테이블의 각 항목은 해당 가상 페이지의 물리 페이지 주소를 가지고 있다. 디스크로 스왑되지 않는다.
  - 선형 페이지 테이블은 연속된 물리 메모리 공간을 차지하는데, 큰 페이지 테이블의 경우 연속된 빈 물리 메모리를 찾는 것이 쉽지 않다.
- 멀티 레벨 페이징에서는 페이지 디렉터리를 사용하여 각 페이지 테이블들의 위치를 파악할 수 있어, 페이지 테이블을 위한 공간 할당이 매우 유연한다. (페이지 테이블의 페이지들을 연속된 공간에 배치하지 않아도 된다)

> [!TIP] 시간과 공간의 절충점
> 자료 구조 설계 시, 시간과 공간의 소요 시간을 적절히 절충해야 한다. 접근 속도를 향상시키려면 공간을 더 사용해야 한다.

**멀티 레벨 페이지가 무조건 좋은 점만 있는 건 아니다. 단점도 있다.**
- 멀티 레벨 테이블에는 추가 비용이 발생한다.
  - TLB 미스 시 주소 변환을 위해 두 번의 메모리 로드가 발생한다.(Page Directory, PTE 접근)
  - TLB 히트 시 성능은 동일하지만, TLB 미스 시에는 두 배의 시간이 소요된다.
  - 공간과 시간의 상호 절충의 예시이다.
- 복잡도가 증가한다. 페이지 테이블 검색이 단순 선형 페이지 테이블의 경우보다 복잡하다.
  - 일반적으로, 성능 개선이나 부하 경감을 위해 복잡한 기법을 도입한다. 여기선 메모리 절약을 위해 페이지 테이블 검색을 복잡하게 만드는 것이다.

### 멀티 레벨 페이징 예제
![](23.%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%83%E1%85%A5%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%8B%E1%85%B3%E1%86%AB%20%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%86%AF/image%204.png)<!-- {"width":577} -->
- 선형 페이지 테이블에서는 14비트 주소공간(VPN 8비트, 페이지 오프셋 6비트)가 필요하다.
- 가상 페이지 0, 1은 코드, 가상 페이지 4, 5는 힙, 그리고 가상 페이지 254, 255는 스택으로 사용된다.

이걸 2단계 페이지 테이블로 구성해보자. 선형 페이지 테이블을 페이지 단위로 분할해야 한다. PTE는 4바이트라고 가정하자.
- 페이지 테이블의 크기는 256 x 4Byte = 1KB이다. 
- 페이지가 64바이트라고 하면, 페이지 테이블은 16개의 64바이트 페이지들로 분할된다. 
- 각 페이지에는 16개의 PTE가 있다.

VPN으로부터 페이지 디렉터리 인덱스를 추출하고, 페이지 테이블의 각 페이지 위치를 파악하는 방법을 알아야 한다.
먼저, 페이지 디렉터리의 인덱스를 만들어보자. 
- 페이지 디렉터리는 페이지 테이블의 각 페이지마다 하나씩 있어야 하므로 총 16개의 항목이 있어야 한다. 
- VPN 상위 4비트를 사용하여 디렉터리를 구성한다.
![](23.%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%83%E1%85%A5%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%8B%E1%85%B3%E1%86%AB%20%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%86%AF/image%205.png)<!-- {"width":647} -->
- VPN에서 페이지-디렉터리 인덱스(PDIndex)를 추출하고 나면 `PDEAddr = PageDirBase + (PDIndex * sizeof(PDE))`를 통해 페이지-디렉터리 항목(PDE)의 주소를 얻을 수 있다.
- 만약 PDE가 invalid라고 표현되어 있으면 예외가 발생한다.
PDE에 접근하여, 페이지 테이블 내의 PFN을 얻게 된다.

이제 원하는 PTE를 읽어들여 보자.
![](23.%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%83%E1%85%A5%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%8B%E1%85%B3%E1%86%AB%20%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%86%AF/image%206.png)<!-- {"width":655} -->
- 이 페이지 테이블 인덱스(PTIndex)는 페이지 테이블 자체의 인덱스로 사용된다. 
- 페이지 테이블의 페이지 내부에서 몇 번째 PTE 인지 식별하는 용도로 사용된다.
- `PTEAddr = (PDE.PFN << SHIFT) + (PTIndex * sizeof(PTE))`

> [!TIP] 복잡도를 주의하자.
> 시스템 설계자들은 시스템의 복잡도 증가를 주의해야 한다. 좋은 개발자는 최소한의 복잡도를 갖는 시스템을 만든다.
> - 디스크 공간이 풍부한데, 공간 사용을 최소하하려고 복잡하게 설계하면 안된다.
> - 프로세서가 충분히 빠른데, CPU 최적화하려고 치밀하게 코드를 짜는 것 보단 이해하기 쉬운 모듈을 작상하는 것이 좋다.
> *“완벽함은 무엇인가 더 추가할 것이 없을 때 얻어지는 것이 아니라, 더 이상 뺄 것이 없을 때 마침내 얻어진다”, 생텍쥐페리*

### 예제
실제 값을 넣은 후에 하나의 가상 주소를 변환해보자.
![](23.%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%83%E1%85%A5%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%8B%E1%85%B3%E1%86%AB%20%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%86%AF/image%207.png)<!-- {"width":588} -->
- PDE는 주소 공간의 페이지 테이블의 페이지에 대해 기술하고 있다. 
- 물리 페이지 100에 페이지 테이블의 첫 항목 16개가 존재한다.
- 페이지 테이블의 첫 번째 페이지(PFN:100)에는 첫 16개의 VPN과 물리 페이지 주소가 있다. VPN 0과 1이 유효하고(코드), 4와 5도 유효하다.(힙) 그러므로 각 페이지들의 매핑 정보가 있다.
- PFN 101에는 가상 주소 공간의 마지막 16개의 VPN에 대한 매핑이 담겨있다. VPN 254, 255(스택)이 유효 페이지이다.

이 예제를 통해 멀티 레벨 인덱스 구조가 공간을 얼만큼 절약할 수 있는지 확인할 수 있다. 
- 선형 페이지 테이블에서는 16개의 페이지들을 모두 할당했지만, 멀티 레벨 페이지에서는 단 세 개만 할당했다.
  - 페이지 디렉터리를 위한 한 페이지, 유효한 매핑 정보를 갖고 있는 페이지 테이블 두 부분을 위해 두 페이지
  - 더 큰 주소 공간에서는 더 많은 공간이 절약된다.

VPN 254 (`11 1111 1000 0000`)를 주소 변환해보자.
- 상위 4비트는 페이지 디렉터리 내의 항목을 가리키기 위해 사용한다.(PDE)
  - `1111` -> 마지막 엔트리
  - 물리 프레임 주소 101이 저장되어 있다. (Mem Access)
- VPN의 다음의 4비트(1110)를 인덱스로 사용하여 페이지 테이블에서 원하는 PTE를 찾는다.
  - `1110`은 101번 페이지의 16개 항목 중에서 마지막 두번째 항목
  - 물리 페이지 번호(PFN) 55가 저장되어 있다. (Mem Access)
  - offset은 나머지 `000000` 이다.
  - `PhysAddr = (PTE.PFN << SHIFT) + offset`

### 2단계 이상 사용하기
지금까지 멀티 레빌 페이지에서 페이지 디렉터리와 페이지 테이블의 2개 단계를 가정했다.
경우에 따라 트리의 단계를 더 증가시키는 것도 가능하다.

멀티 레벨 페이지 테이블의 목적은 페이지 **테이블의 모든 분할된 부분들이 단일 페이지 크기에 맞도록 하는 것이다.**  만약 페이지 디렉터리가 너무 커지면 어떻게 될까?

멀티 레벨 테이블에서 몇 단계를 둘지 정하기 위해서는 **먼저 한 페이지에 몇 개의 페이지 테이블 항목을 저장할 수 있을지를 계산해야 한다.** 페이지 크기가 512바이트이고 PTE의 크기가 4바이트라고 하면, 한 페이지에 128개의 PTE를 넣을 수 있다.
테이블의 페이지를 인덱스로 쓰려면, VPN의 하위 7비트($log_2{128}$ )가 필요하다.

![](23.%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%83%E1%85%A5%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%8B%E1%85%B3%E1%86%AB%20%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%86%AF/image%208.png)
- 14개의 비트가 남는다. 즉, 페이지 디렉터리에 2^14개 항목이 있게 된다.
- 페이지 디렉터리를 위해서는 128페이지 분량의 연속된 메모리가 필요하다.
  - 각 엔트리의 크기가 4B라면, 총 64KB이다.
  - 페이지의 크기가 512B이므로, 128페이지가 필요하다.
  - 즉, 페이지 디렉터리 하나를 저장하는데 무려 128개의 연속된 페이지가 필요하다.
- 페이지 테이블을 페이지 단위로 나누어 배치할 수 있도록 하는 멀티 레벨 페이지 테이블의 근본 취지가 회손되어버렸다.

![](23.%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%83%E1%85%A5%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%8B%E1%85%B3%E1%86%AB%20%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%86%AF/image%209.png)
이 문제를 해결하기 위해, 페이지 디렉터리 자체를 멀티 페이지들로 나누어서 트리의 단계를 늘리도록 한다. 페이지 디렉터리의 페이지들을 가리킬 수 있도록 그 위에 새로운 페이지 디렉토리를 추가하는 것이다.

이제 가상 주소의 최상위 비트들을(PD Index0) 사용하여 상위 단계의 페이지 디렉터리 엔트리를 찾는다. 이 인덱스를 사용하여 사위 단계 페이지 디렉터리에서 페이지 디렉터리 항목을 가져온다. 만약 유효하다면 상위 단계 디렉토리에서 얻은 물리 주소와 두 번째 단계의 페이지 데릭터리 인덱스 (PD Index1)을 결합하여 페이지 테이블 인덱스가 존재한 물리 페이지를 구한다. (최종 PDE 인듯?)

최종 PDE?를 구했으므로, PTE 주소는 2번째 단계의 페이지 디렉터리 항목에서 얻은 페이지 테이블의 물리 주소와 페이지 테이블 인덱스를 결합하여 구할 수 있다.

여기서 알 수 있는 건, 실제 주소를 구하는 데 드는 작업이 상당하다는 것이다.

### 변환 과정: TLB를 기억하자
![](23.%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%83%E1%85%A5%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%8B%E1%85%B3%E1%86%AB%20%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%86%AF/image%2010.png)<!-- {"width":747} -->
- 복잡한 멀티 레벨 페이지 테이블 접근 전에, TLB 검사를 한다.
- TLB 미스 시에만 멀티 레벨 페이지 테이블의 모든 단계를 거쳐 물리 주소를 구하게 된다.
- TLB 미스 발생 시, 전통적인 2단계 페이지 테이블의 주소 계산 비용을 볼 수 있다. 두 번의 추가 메모리 접근이 발생한다.

## 23.4 역 페이지 테이블
조금 더 획기적인 공간 절약 방법으로, **역 페이지 테이블(inverted page table)**이 있다. 
- 이 방법에서는 여러 개의 페이지 테이블(시스템의 프로세스당 하나씩) 대신 **시스템에 단 하나의 페이지 테이블**만 둔다.
- 역 페이지 테이블의 각 항목은 해당 물리 페이지를 사용 중인 프로세스 번호, 해당 가상 페이지 번호를 갖고 있다.
  - 가상 -> 물리가 아니라, 물리 -> 가상이다.
- 역 페이지 테이블에서는 주소 변환을 위해 전체 테이블을 검색해서 원하는 가상 주소 페이지를 갖는 항목을 찾아야 한다.
  - 순차 탐색은 느리므로, 해시 테이블을 주로 사용한다.

멀티 레벨 페이지와 역 페이지 테이블은 다양한 방법 중 두 가지 예일 뿐이다. 방법은 많다.

## 23.5 페이지 테이블을 디스크로 스와핑하기
이제까지 페이지 테이블이 커널이 소유하고 있는 물리 메모리 영역에 존재한다고 가정했다. 
페이지 테이블이 차지하는 메모리 공간 축소를 위해 많은 시도를 했지만, 여전히 모든 페이지 테이블을 메모리에 상주시키기에는 양이 너무 많을 수도 있다. 그래서 어떤 시스템은 페이지 테이블을 **커널 가상 메모리에** 존재시키고, 시스템의 메모리가 부족한 경우 **페이지 테이블들을 디스크로 스왑하기도 한다.** (뒷 장에서 구체적으로 다룬다)

## 23.6 요약
여러 구조의 페이지 테이블을 살펴 보았다. 공간을 많이 소모하는 테이블일 수록 TLB 미스 처리 속도가 빨라지고, 공간을 작게 차지하는 테이블 구조를 사용하면 상황은 반대가 된다.

과거 시스템에서는 소형 자료 구조 사용이 현명했다. 적당한 크기의 메모리와 다수의 페이지를 사용하는 워크로드의 경우 TLB 미스를 신속히 처리할 수 있는 큰 테이블을 사용하는 것이 옳은 선택이다.

소프트웨어 기반 TLB는 OS 개발자가 임의로, 혁신적으로 자료구조를 개발/개선할 수 있다.

## 구현 코드 실행 결과
```
== LinearPageTable + TLB(LRU) ==
PageTable memory: 4.00 MB
TLB entries: (included in name)
Total refs: 20000
Successes: 20000
Faults: 0
TLB hits: 10351 (51.76%)
TLB misses: 9649 (48.25%)
Page-walk mem accesses (sum): 9649
Avg walk mem accesses per ref: 0.4825
Avg walk mem accesses per miss: 1.0000


== HybridSegmentedPageTable + TLB(LRU) ==
PageTable memory: 1.00 MB
TLB entries: (included in name)
Total refs: 20000
Successes: 20000
Faults: 0
TLB hits: 10351 (51.76%)
TLB misses: 9649 (48.25%)
Page-walk mem accesses (sum): 9649
Avg walk mem accesses per ref: 0.4825
Avg walk mem accesses per miss: 1.0000


== TwoLevelPageTable + TLB(LRU) ==
PageTable memory: 16.00 KB
TLB entries: (included in name)
Total refs: 20000
Successes: 20000
Faults: 0
TLB hits: 10351 (51.76%)
TLB misses: 9649 (48.25%)
Page-walk mem accesses (sum): 19298
Avg walk mem accesses per ref: 0.9649
Avg walk mem accesses per miss: 2.0000


== InvertedPageTable(HashLookup) + TLB(LRU) ==
PageTable memory: 768.00 KB
TLB entries: (included in name)
Total refs: 20000
Successes: 20000
Faults: 0
TLB hits: 10351 (51.76%)
TLB misses: 9649 (48.25%)
Page-walk mem accesses (sum): 9649
Avg walk mem accesses per ref: 0.4825
Avg walk mem accesses per miss: 1.0000
```
- Linear: 4.00MB (주소공간 전체 VPN에 대해 PTE를 갖는 낭비)
- Hybrid: 1.00MB (세그먼트별로 줄였지만, 네 실험은 스택 bound가 커서 여전히 큼)
- Two Level: 16.00KB
- Inverted: 768KB (여기선 “물리 프레임 수 × 엔트리 크기”로 잡혀서 중간)

- TwoLevel: miss당 page-walk = 2 → “TLB miss가 잦을수록 확실히 느려짐”

- Linear/Hybrid/Inverted: `Avg walk per ref = 0.4825`, TwoLevel: `Avg walk per ref = 0.9649`
    - 선형/하이브리드/역PT는 “추가로” 평균 0.4825번 메모리를 더 읽고, 2단계 멀티레벨은 평균 0.9649번을 더 읽는다는 뜻.
    - TLB miss가 많을 때 멀티레벨이 확실히 느려지는 이유

# 깔끔하게 요약
## 1) 기술의 목적
* 이 장의 목적은 **페이지 테이블의 “크기” 문제**를 해결하는 것이다.
* 선형(배열) 페이지 테이블은 주소 공간 전체에 대해 PTE를 갖기 때문에, **프로세스가 실제로 쓰지 않는 가상 페이지까지도 테이블 항목이 필요**해져 메모리를 과도하게 소모한다.
* 예로, 32비트 주소 공간 + 4KB 페이지 + 4B PTE이면 **프로세스당 4MB**, 100개면 **400MB**가 페이지 테이블로만 소비된다.

## 2) 문제의 핵심
* 페이지 테이블은 “매핑 정보”를 담는데, 주소 공간은 보통 **드문드문 사용**된다.
* 그 결과 선형 페이지 테이블은 **대부분이 비어 있는 상태로 메모리에 존재**하여 낭비가 발생한다.

## 3) 해결 시도 1: 더 큰 페이지
### 아이디어
* 페이지 크기를 키우면 페이지 수가 줄고, 그만큼 **PTE 개수가 줄어 페이지 테이블 크기가 감소**한다.
* 4KB → 16KB로 키우면, 페이지 개수가 1/4이 되어 페이지 테이블도 **1/4로 감소**한다.

### 남는 문제점
* 페이지가 커질수록 **페이지 내부에서 사용하지 못하는 공간(내부 단편화)**이 증가한다.
* 결국 메모리 낭비가 커지고 메모리가 빨리 고갈되므로, 페이지 크기를 크게 키우는 것은 어렵다.

## 4) 해결 시도 2: 하이브리드(페이징 + 세그멘트)
### 아이디어
* 주소 공간은 코드/힙/스택처럼 “논리 구획”이 뚜렷하고, 실제 사용도 구획별로 몰려 있으므로
  **페이지 테이블 자체를 세그먼트별로 나누어** 낭비를 줄인다.
* 구조는 `논리 세그먼트 : 페이지 테이블 = 1 : 1` 형태가 된다.
* 하드웨어는 코드/힙/스택 각각에 대해 **베이스/바운드 레지스터 쌍**을 가진다.
  * 베이스: 해당 세그먼트의 **페이지 테이블 시작 물리 주소**
  * 바운드: 해당 세그먼트의 **최대 유효 페이지 개수**
* TLB 미스 시에는 가상 주소의 세그먼트 비트로 세그먼트를 식별하고, 그 세그먼트의 베이스를 이용해 PTE 주소를 계산한다.

### 남는 문제점
* 페이지 테이블에 세그멘테이션을 적용했지만, **세그멘테이션의 한계가 그대로 남는다.**
  * 주소 공간 사용 패턴이 예상과 다르면(예: 드문드문 쓰는 힙) **여전히 낭비가 발생**한다.
  * 서로 다른 크기의 페이지 테이블을 메모리에 배치해야 하므로, 페이지 테이블을 위한 공간 확보가 복잡해지고 **외부 단편화 문제가 다시 등장**한다.

## 5) 해결 시도 3: 멀티 레벨 페이지 테이블
### 아이디어
* 선형 페이지 테이블을 **페이지 크기 단위로 쪼개고**, 전부 invalid인 “페이지 테이블의 페이지”는 **아예 할당하지 않는다.**
* 어떤 페이지 테이블 조각이 존재하는지와 위치는 **페이지 디렉터리**가 관리한다.
* PDE는 PTE처럼 valid 비트와 PFN을 가지며, **PDE가 valid라는 뜻은 그가 가리키는 페이지 테이블 페이지 안에 유효한 PTE가 최소 하나 존재**한다는 의미이다.

### 장점
* 페이지 테이블 메모리 사용이 **“사용된 주소 공간 크기”에 비례**하게 된다.
* 페이지 테이블을 페이지 단위로 할당하므로, 운영체제는 필요할 때 **free 페이지 풀에서 페이지를 가져다** 쓸 수 있어 관리가 유연해진다.
* 페이지 테이블 페이지들을 연속으로 배치할 필요가 없고, 디렉터리가 위치를 알게 해주므로 **할당이 유연**해진다.

### 남는 문제점(시간-공간 절충)
* TLB 미스 시 주소 변환이 **추가 메모리 로드**를 요구한다.
  * 2단계라면 디렉터리 접근 1번 + PTE 접근 1번으로, **TLB 미스 비용이 커진다.**
* 구조가 트리 형태라서 선형보다 **검색 과정이 복잡**해진다.

### 단계가 더 늘어나는 경우
* 목적은 **페이지 테이블의 모든 분할 조각이 한 페이지 크기에 맞게** 만드는 것이다.
* 그런데 페이지 디렉터리가 너무 커져서 디렉터리 자체가 여러 페이지(예: 128페이지)로 커지면, “유연한 할당”이라는 취지가 약해진다.
* 이를 해결하려고 **디렉터리 자체도 다시 여러 페이지로 쪼개고 단계(레벨)를 늘린다.**
* 즉, 최상위 인덱스 → 하위 디렉터리 → 최종 디렉터리(PDE) → PTE 순으로 따라가게 되어, TLB 미스 시 변환 작업이 더 복잡해진다.
* 이때도 핵심은 **먼저 TLB를 확인하고, TLB 미스일 때만 멀티 레벨을 모두 수행**한다는 점이다.

## 6) 해결 시도 4: 역 페이지 테이블
### 아이디어
* 프로세스마다 페이지 테이블을 두는 대신, **시스템 전체에 페이지 테이블을 하나만 둔다.**
* 각 항목은 “이 물리 페이지를 누가(프로세스 번호), 어떤 가상 페이지 번호로 쓰는가”를 담는다.
  * 즉, 매핑 방향이 **물리 → 가상**이다.
* 주소 변환은 해당 가상 주소를 가진 항목을 찾아야 하므로, 전체 검색은 느려 **해시 테이블을 주로 사용**한다.

### 남는 문제점
* 원하는 항목을 찾기 위한 **탐색 비용**이 발생한다(순차 탐색은 느림 → 해시 사용).

## 7) 추가 절약: 페이지 테이블을 디스크로 스와핑
* 페이지 테이블을 항상 물리 메모리에 상주시킬 수 없을 정도로 많아질 수 있어,
  어떤 시스템은 페이지 테이블을 **커널 가상 메모리에 두고**, 메모리가 부족하면 **디스크로 스왑**하기도 한다.

## 8) 전체 흐름 요약
* 문제: 선형 페이지 테이블은 실제 사용과 무관하게 주소 공간 전체를 커버하여 **크기가 너무 크다.**
* 해결 방향:
  1. 페이지 크기 증가로 PTE 수를 줄이려 했지만 → **내부 단편화**가 커진다.
  2. 세그먼트별 페이지 테이블로 낭비를 줄이려 했지만 → 패턴 가정 한계, **외부 단편화**가 다시 나타난다.
  3. 멀티 레벨로 “필요한 조각만 할당”하여 공간을 크게 절약하지만 → TLB 미스 시 **추가 메모리 접근**이라는 비용이 생긴다. 디렉터리가 커지면 레벨을 더 늘려야 한다.
  4. 역 페이지 테이블로 시스템에 하나만 두어 공간을 아끼지만 → **탐색 비용**이 생겨 해시를 쓴다.
  5. 그래도 많으면 페이지 테이블 자체를 **디스크로 스왑**하기도 한다.
* 결론: 페이지 테이블은 **공간을 줄이면 변환(특히 TLB 미스 처리)이 느려지고**, 빠르게 하려면 **공간을 더 쓰게 되는** 시간-공간 절충 구조이다.
